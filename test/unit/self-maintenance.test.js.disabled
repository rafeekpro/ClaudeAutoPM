/**
 * Unit tests for self-maintenance.js
 * Tests the PM command logic that was migrated from bash to Node.js
 */

const { describe, it, beforeEach, afterEach } = require('node:test');
const assert = require('node:assert');
const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');

// Mock modules
const mockFs = {
  existsSync: () => true,
  readFileSync: () => '{}',
  readdirSync: () => [],
  mkdirSync: () => {},
  rmSync: () => {},
  statSync: () => ({
    isDirectory: () => false,
    isFile: () => true
  })
};

const mockSpawnSync = {
  status: 0,
  stdout: 'mock output',
  stderr: '',
  error: null
};

// Load the module once at the top level for better performance
const SelfMaintenance = require('../../../scripts/self-maintenance.js');

// Mock management helper
class MockManager {
  constructor() {
    this.mocks = [];
  }

  add(object, property, mockValue) {
    const original = object[property];
    this.mocks.push({ object, property, original });
    object[property] = mockValue;
    return mockValue;
  }

  restoreAll() {
    this.mocks.forEach(({ object, property, original }) => {
      object[property] = original;
    });
    this.mocks = [];
  }
}

describe('SelfMaintenance Class', () => {
  let originalConsoleLog;
  let consoleOutput;
  let mockManager;

  beforeEach(() => {
    // Initialize mock manager
    mockManager = new MockManager();

    // Capture console output
    consoleOutput = [];
    originalConsoleLog = console.log;
    console.log = (...args) => consoleOutput.push(args.join(' '));
  });

  afterEach(() => {
    // Restore console.log
    console.log = originalConsoleLog;

    // Restore all mocks systematically
    if (mockManager) {
      mockManager.restoreAll();
    }
  });

  describe('Constructor and Initialization', () => {
    it('should initialize with correct project paths', () => {
      const maintenance = new SelfMaintenance();

      assert.ok(maintenance.projectRoot, 'Project root should be set');
      assert.ok(maintenance.agentRegistry.includes('AGENT-REGISTRY.md'),
        'Agent registry path should be set');
      assert.ok(maintenance.agentsDir.includes('agents'),
        'Agents directory should be set');
    });

    it('should initialize metrics object', () => {
      const maintenance = new SelfMaintenance();

      assert.ok(maintenance.metrics, 'Metrics object should exist');
      assert.equal(typeof maintenance.metrics.totalAgents, 'number',
        'Total agents metric should be initialized');
      assert.equal(typeof maintenance.metrics.deprecatedAgents, 'number',
        'Deprecated agents metric should be initialized');
      assert.equal(typeof maintenance.metrics.contextEfficiency, 'number',
        'Context efficiency metric should be initialized');
    });

    it('should set default constants', () => {
      const maintenance = new SelfMaintenance();

      assert.equal(maintenance.DEFAULT_INSTALL_OPTION, '3',
        'Default install option should be 3 (Full DevOps)');
      assert.ok(maintenance.SCENARIO_MAP, 'Scenario map should exist');
      assert.equal(maintenance.SCENARIO_MAP.minimal, '1',
        'Minimal scenario should map to 1');
      assert.equal(maintenance.SCENARIO_MAP.full, '3',
        'Full scenario should map to 3');
    });
  });

  describe.skip('runHealthCheck() - SKIPPED: readline causes hanging', () => {
    it('should generate health report with all components', async () => {
      const maintenance = new SelfMaintenance();

      // Mock file system calls
      mockManager.add(fs, 'existsSync', (path) => {
        // Return true for expected paths, false for others
        return true;
      });
      mockManager.add(fs, 'readFileSync', (path) => {
        if (path.includes('AGENT-REGISTRY.md')) {
          return '# Agent Registry\n- agent1\n- agent2';
        }
        if (path.includes('package.json')) {
          return JSON.stringify({ version: '1.0.0' });
        }
        if (path.includes('CHANGELOG.md')) {
          return '# Changelog\n## 1.0.0';
        }
        return '';
      });
      mockManager.add(fs, 'readdirSync', (path) => ['agent1.md', 'agent2.md']);
      mockManager.add(fs, 'statSync', (path) => ({
        isDirectory: () => path.includes('agents'),
        isFile: () => !path.includes('agents')
      }));

      // Mock spawnSync for git commands
      const childProcess = require('child_process');
      mockManager.add(childProcess, 'spawnSync', (cmd, args) => {
        if (cmd === 'git' && args[0] === 'log') {
          return { stdout: '1 hour ago', status: 0 };
        }
        if (cmd === 'npm' && args[0] === 'test') {
          return { status: 0 };
        }
        return { status: 0, stdout: '' };
      });

      await maintenance.runHealthCheck();

      const output = consoleOutput.join('\n');
      assert.ok(output.includes('Health Report'), 'Should show health report title');
      assert.ok(output.includes('Agent Ecosystem'), 'Should show agent ecosystem');
      assert.ok(output.includes('Test Status'), 'Should show test status');
      assert.ok(output.includes('Documentation'), 'Should show documentation status');
      assert.ok(output.includes('Last commit'), 'Should show last commit info');
    });

    it('should handle missing agent registry', async () => {
      const maintenance = new SelfMaintenance();
      const mockManager = new MockManager();

      mockManager.add(fs, 'existsSync', (path) => {
        if (path.includes('AGENT-REGISTRY.md')) {
          return false;
        }
        return true;
      });

      try {
        await maintenance.runHealthCheck();

        const output = consoleOutput.join('\n');
        assert.ok(output.includes('Health Report'), 'Should still generate report');
      } finally {
        mockManager.restoreAll();
      }
    });

    it('should show recommendations based on agent count', async () => {
      const maintenance = new SelfMaintenance();
      const mockManager = new MockManager();

      // Mock high agent count
      maintenance.metrics.totalAgents = 65;

      mockManager.add(fs, 'existsSync', () => true);

      try {
        await maintenance.runHealthCheck();

        const output = consoleOutput.join('\n');
        assert.ok(output.includes('Consider further agent consolidation'),
          'Should recommend consolidation for high agent count');
      } finally {
        mockManager.restoreAll();
      }
    });
  });

  describe.skip('runValidation() - SKIPPED: readline causes hanging', () => {
    it('should validate all required components', async () => {
      const maintenance = new SelfMaintenance();
      const mockManager = new MockManager();
      const child_process = require('child_process');

      mockManager.add(fs, 'existsSync', () => true);
      mockManager.add(child_process, 'spawnSync', () => ({ status: 0, stdout: '' }));

      try {
        await maintenance.runValidation();

        const output = consoleOutput.join('\n');
        assert.ok(output.includes('Validating'), 'Should show validation title');
        assert.ok(output.includes('Agent registry'), 'Should validate agent registry');
        assert.ok(output.includes('Configuration'), 'Should validate configuration');
        assert.ok(output.includes('Installation script'), 'Should validate installation');
        assert.ok(output.includes('Documentation'), 'Should validate documentation');
        assert.ok(output.includes('Test suite'), 'Should run test suite');
      } finally {
        mockManager.restoreAll();
      }
    });

    it('should report validation failures', async () => {
      const maintenance = new SelfMaintenance();
      const mockManager = new MockManager();
      const child_process = require('child_process');

      mockManager.add(fs, 'existsSync', (path) => {
        if (path.includes('README.md')) {
          return false; // Simulate missing README
        }
        return true;
      });
      mockManager.add(child_process, 'spawnSync', () => ({ status: 1 })); // Simulate test failure

      try {
        await maintenance.runValidation();

        const output = consoleOutput.join('\n');
        assert.ok(output.includes('❌'), 'Should show failure indicators');
        assert.ok(output.includes('issues') || output.includes('failed'),
          'Should indicate validation issues');
      } finally {
        mockManager.restoreAll();
      }
    });
  });

  describe.skip('runOptimization() - SKIPPED: readline causes hanging', () => {
    it('should analyze optimization opportunities', async () => {
      const maintenance = new SelfMaintenance();

      const originalReaddirSync = fs.readdirSync;
      const originalReadFileSync = fs.readFileSync;
      const originalExistsSync = fs.existsSync;

      fs.existsSync = () => true;
      fs.readdirSync = (path) => {
        if (path.includes('agents')) {
          return [
            'core', 'frameworks', 'databases', 'cloud', 'devops'
          ];
        }
        return ['agent1.md', 'agent2.md', 'deprecated-agent.md'];
      };
      fs.readFileSync = (path) => {
        if (path.includes('deprecated')) {
          return 'DEPRECATED: This agent is deprecated';
        }
        return '# Agent\nThis is an agent';
      };

      try {
        await maintenance.runOptimization();

        const output = consoleOutput.join('\n');
        assert.ok(output.includes('Optimization Analysis'), 'Should show optimization title');
        assert.ok(output.includes('Agent Analysis'), 'Should analyze agents');
        assert.ok(output.includes('Context Efficiency'), 'Should analyze context efficiency');
        assert.ok(output.includes('Recommendations'), 'Should provide recommendations');
      } finally {
        fs.readdirSync = originalReaddirSync;
        fs.readFileSync = originalReadFileSync;
        fs.existsSync = originalExistsSync;
      }
    });

    it('should identify consolidation opportunities', async () => {
      const maintenance = new SelfMaintenance();

      const originalReaddirSync = fs.readdirSync;
      const originalReadFileSync = fs.readFileSync;
      const originalExistsSync = fs.existsSync;

      fs.existsSync = () => true;
      fs.readdirSync = (path) => {
        if (path.includes('frameworks')) {
          // Simulate multiple similar framework agents
          return [
            'react-ui-expert.md',
            'react-frontend-engineer.md',
            'react-component-specialist.md',
            'mui-react-expert.md',
            'antd-react-expert.md'
          ];
        }
        return [];
      };
      fs.readFileSync = () => '# React Agent';

      try {
        await maintenance.runOptimization();

        const output = consoleOutput.join('\n');
        assert.ok(
          output.includes('Consider consolidating') ||
          output.includes('similar agents'),
          'Should identify consolidation opportunities'
        );
      } finally {
        fs.readdirSync = originalReaddirSync;
        fs.readFileSync = originalReadFileSync;
        fs.existsSync = originalExistsSync;
      }
    });
  });

  describe.skip('runTestInstall() - SKIPPED: readline causes hanging', () => {
    it('should test all installation scenarios', async () => {
      const maintenance = new SelfMaintenance();

      const originalMkdirSync = fs.mkdirSync;
      const originalExistsSync = fs.existsSync;
      const originalRmSync = fs.rmSync;

      let scenariosTested = [];

      fs.mkdirSync = () => {};
      fs.existsSync = (path) => {
        if (path.includes('CLAUDE.md') || path.includes('.claude')) {
          return true; // Simulate successful installation
        }
        return true;
      };
      fs.rmSync = () => {};

      // Mock runInstallScript
      maintenance.runInstallScript = (input, dir) => {
        scenariosTested.push(input);
        return { status: 0 };
      };

      try {
        const results = await maintenance.runTestInstall();

        assert.equal(results.length, 4, 'Should test 4 scenarios');
        assert.ok(scenariosTested.includes('1'), 'Should test minimal scenario');
        assert.ok(scenariosTested.includes('2'), 'Should test docker scenario');
        assert.ok(scenariosTested.includes('3'), 'Should test full scenario');
        assert.ok(scenariosTested.includes('4'), 'Should test performance scenario');

        const successCount = results.filter(r => r.success).length;
        assert.equal(successCount, 4, 'All scenarios should succeed');
      } finally {
        fs.mkdirSync = originalMkdirSync;
        fs.existsSync = originalExistsSync;
        fs.rmSync = originalRmSync;
      }
    });

    it('should handle installation failures', async () => {
      const maintenance = new SelfMaintenance();

      const originalMkdirSync = fs.mkdirSync;
      const originalExistsSync = fs.existsSync;
      const originalRmSync = fs.rmSync;

      fs.mkdirSync = () => {};
      fs.existsSync = (path) => {
        if (path.includes('CLAUDE.md')) {
          return false; // Simulate failed installation
        }
        return true;
      };
      fs.rmSync = () => {};

      maintenance.runInstallScript = () => ({ status: 0 });

      try {
        const results = await maintenance.runTestInstall();

        const failureCount = results.filter(r => !r.success).length;
        assert.equal(failureCount, 4, 'All scenarios should fail');

        const output = consoleOutput.join('\n');
        assert.ok(output.includes('failed'), 'Should indicate failures');
      } finally {
        fs.mkdirSync = originalMkdirSync;
        fs.existsSync = originalExistsSync;
        fs.rmSync = originalRmSync;
      }
    });
  });

  describe('Helper Methods', () => {
    describe('runInstallScript()', () => {
      it('should safely execute installation script', () => {
        const maintenance = new SelfMaintenance();

        const originalSpawnSync = require('child_process').spawnSync;
        let capturedCommand = null;
        let capturedArgs = null;

        require('child_process').spawnSync = (cmd, args, options) => {
          capturedCommand = cmd;
          capturedArgs = args;
          return { status: 0, stdout: 'success' };
        };

        try {
          const result = maintenance.runInstallScript('3', '/test/dir');

          assert.equal(capturedCommand, 'bash', 'Should use bash');
          assert.ok(capturedArgs.includes('/test/dir'), 'Should pass target directory');
          assert.equal(result.status, 0, 'Should return success status');
        } finally {
          require('child_process').spawnSync = originalSpawnSync;
        }
      });

      it('should throw on installation failure', () => {
        const maintenance = new SelfMaintenance();

        const originalSpawnSync = require('child_process').spawnSync;
        require('child_process').spawnSync = () => ({
          status: 1,
          stderr: 'Installation error'
        });

        try {
          assert.throws(
            () => maintenance.runInstallScript('1', '/test/dir'),
            /Installation failed/,
            'Should throw on failure'
          );
        } finally {
          require('child_process').spawnSync = originalSpawnSync;
        }
      });
    });

    describe('countFiles()', () => {
      it('should count files with specific extensions', () => {
        const maintenance = new SelfMaintenance();

        const originalExistsSync = fs.existsSync;
        const originalReaddirSync = fs.readdirSync;
        const originalStatSync = fs.statSync;

        fs.existsSync = () => true;
        fs.readdirSync = (dir) => {
          // Avoid infinite recursion in tests
          if (dir && dir.includes('subdir')) {
            return [];
          }
          return ['file1.js', 'file2.ts', 'file3.js', 'file4.md'];
        };
        fs.statSync = () => ({
          isDirectory: () => false,
          isFile: () => true
        });

        try {
          const count = maintenance.countFiles('/test', ['.js', '.ts']);
          assert.equal(count, 3, 'Should count JS and TS files');
        } finally {
          fs.existsSync = originalExistsSync;
          fs.readdirSync = originalReaddirSync;
          fs.statSync = originalStatSync;
        }
      });

      it('should handle non-existent directories', () => {
        const maintenance = new SelfMaintenance();

        const originalExistsSync = fs.existsSync;
        fs.existsSync = () => false;

        try {
          const count = maintenance.countFiles('/non-existent', ['.js']);
          assert.equal(count, 0, 'Should return 0 for non-existent directory');
        } finally {
          fs.existsSync = originalExistsSync;
        }
      });
    });

    describe('validateRegistry()', () => {
      it('should validate agent registry integrity', () => {
        const maintenance = new SelfMaintenance();

        const originalExistsSync = fs.existsSync;
        const originalReadFileSync = fs.readFileSync;
        const originalReaddirSync = fs.readdirSync;

        fs.existsSync = () => true;
        fs.readFileSync = () => '# Registry\n- agent1\n- agent2';
        fs.readdirSync = () => ['core'];

        try {
          const isValid = maintenance.validateRegistry();
          assert.ok(isValid, 'Registry should be valid');
        } finally {
          fs.existsSync = originalExistsSync;
          fs.readFileSync = originalReadFileSync;
          fs.readdirSync = originalReaddirSync;
        }
      });

      it('should detect registry issues', () => {
        const maintenance = new SelfMaintenance();

        const originalExistsSync = fs.existsSync;
        fs.existsSync = () => false; // Registry doesn't exist

        try {
          const isValid = maintenance.validateRegistry();
          assert.ok(!isValid, 'Registry should be invalid');
        } finally {
          fs.existsSync = originalExistsSync;
        }
      });
    });
  });
});