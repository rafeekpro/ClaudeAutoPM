#!/usr/bin/env node

/**
 * Script to remove AI contributors from git history
 * Node.js implementation of clean-ai-contributors.sh
 * WARNING: This rewrites history - use with caution!
 */

const { execSync, spawn } = require('child_process');
const readline = require('readline');
const fs = require('fs-extra');
const path = require('path');
const colors = require('../lib/utils/colors');

class AIContributorCleaner {
  constructor() {
    this.filterScriptPath = '/tmp/filter-ai.sh';
  }

  /**
   * Prompt user for confirmation
   */
  async promptConfirmation(message) {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    return new Promise((resolve) => {
      rl.question(message, (answer) => {
        rl.close();
        resolve(answer.toLowerCase() === 'y');
      });
    });
  }

  /**
   * Get current AI contributors
   */
  getCurrentAIContributors() {
    try {
      const output = execSync('git shortlog -sne', { encoding: 'utf8' });
      const aiLines = output.split('\n').filter(line =>
        /Claude|Copilot|anthropic|bot/i.test(line)
      );
      return aiLines.length > 0 ? aiLines : ['None found in shortlog'];
    } catch (error) {
      return ['Error checking contributors'];
    }
  }

  /**
   * Find commits with AI co-authors
   */
  findCommitsWithAI() {
    try {
      const output = execSync(
        'git log --all --format=\'%H\' --grep="Co-[Aa]uthored-[Bb]y.*Claude\\|Co-[Aa]uthored-[Bb]y.*Copilot"',
        { encoding: 'utf8' }
      );
      return output.trim().split('\n').filter(Boolean);
    } catch (error) {
      // No commits found
      return [];
    }
  }

  /**
   * Create filter script
   */
  async createFilterScript() {
    const script = `#!/bin/bash
# Remove AI co-author lines from commit messages
sed \\
    -e '/Co-[Aa]uthored-[Bb]y:.*[Cc]laude/d' \\
    -e '/Co-[Aa]uthored-[Bb]y:.*[Cc]opilot/d' \\
    -e '/Co-[Aa]uthored-[Bb]y:.*anthropic/d' \\
    -e '/Co-[Aa]uthored-[Bb]y:.*github-actions/d' \\
    -e '/Co-[Aa]uthored-[Bb]y:.*\\[bot\\]/d' \\
    -e '/Generated with.*Claude/d' \\
    -e '/Generated by.*Copilot/d' \\
    -e '/🤖.*Generated/d'`;

    await fs.writeFile(this.filterScriptPath, script);
    await fs.chmod(this.filterScriptPath, '755');
  }

  /**
   * Run git filter-branch
   */
  runFilterBranch() {
    console.log('');
    console.log('⏳ Running git filter-branch (this may take a while)...');

    try {
      execSync(
        `git filter-branch --msg-filter 'cat | ${this.filterScriptPath}' -- --all`,
        { stdio: 'inherit' }
      );
      return true;
    } catch (error) {
      console.error(colors.red('Error during filter-branch:'), error.message);
      return false;
    }
  }

  /**
   * Clean up after filtering
   */
  cleanup() {
    console.log('');
    console.log('🧹 Cleaning up...');

    try {
      // Remove filter script
      fs.removeSync(this.filterScriptPath);

      // Remove backup refs
      execSync('git for-each-ref --format="%(refname)" refs/original/ | xargs -n 1 git update-ref -d');

      // Expire reflog
      execSync('git reflog expire --expire=now --all');

      // Run garbage collection
      execSync('git gc --prune=now');

      return true;
    } catch (error) {
      console.error(colors.yellow('Warning during cleanup:'), error.message);
      return false;
    }
  }

  /**
   * Main execution
   */
  async run() {
    console.log(colors.bold('🧹 Cleaning AI Contributors from Git History'));
    console.log('='.repeat(44));
    console.log('');
    console.log(colors.yellow('⚠️  WARNING: This will rewrite git history!'));
    console.log('   Make sure all team members are aware before proceeding.');
    console.log('');

    const confirmed = await this.promptConfirmation('Are you sure you want to continue? (y/N): ');

    if (!confirmed) {
      console.log(colors.red('❌ Aborted.'));
      process.exit(1);
    }

    console.log('');
    console.log('📊 Current contributors with AI:');
    const aiContributors = this.getCurrentAIContributors();
    aiContributors.forEach(contrib => console.log(contrib));

    console.log('');
    console.log('🔍 Searching for AI co-authors in commit messages...');
    const commitsWithAI = this.findCommitsWithAI();

    if (commitsWithAI.length === 0) {
      console.log(colors.green('✅ No AI co-authors found in commit history!'));
      process.exit(0);
    }

    console.log(`Found ${commitsWithAI.length} commits with AI co-authors`);
    console.log('');
    console.log('🔧 Cleaning commit messages...');

    // Create filter script
    await this.createFilterScript();

    // Run filter-branch
    const filterSuccess = this.runFilterBranch();

    if (!filterSuccess) {
      console.log(colors.red('❌ Failed to clean commits'));
      process.exit(1);
    }

    // Cleanup
    this.cleanup();

    console.log('');
    console.log(colors.green('✅ Successfully cleaned AI contributors from history!'));
    console.log('');
    console.log(colors.yellow('⚠️  Important next steps:'));
    console.log('1. Force push to remote: git push --force-with-lease');
    console.log('2. Notify all team members to re-clone or reset their local repos');
    console.log('3. Close and re-open any open pull requests');
  }
}

// Run if called directly
if (require.main === module) {
  const cleaner = new AIContributorCleaner();
  cleaner.run().catch(error => {
    console.error(colors.red('Fatal error:'), error.message);
    process.exit(1);
  });
}

module.exports = AIContributorCleaner;