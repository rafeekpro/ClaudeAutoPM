# Language Agents

Specialized agents for specific programming languages. Each agent understands language idioms, best practices, and ecosystem tools.

## Available Agents

### 🐍 python-backend-engineer
- **Expertise**: Python, FastAPI, SQLAlchemy, async programming
- **Tools**: uv, ruff, black, mypy, pytest
- **Specialties**: REST APIs, database integration, microservices

### 🟨 javascript-frontend-engineer
- **Expertise**: Modern JavaScript, TypeScript, ES6+, browser APIs
- **Tools**: Webpack, Vite, ESLint, Prettier, Jest
- **Specialties**: DOM manipulation, async patterns, performance optimization

### 🟢 nodejs-backend-engineer
- **Expertise**: Node.js, Express, NestJS, server-side TypeScript
- **Tools**: PM2, nodemon, ESLint, Mocha/Jest
- **Specialties**: REST APIs, GraphQL, WebSockets, microservices

## Planned Agents

### 🦀 rust-systems-engineer
- **Expertise**: Rust, Tokio, Actix, embedded systems
- **Tools**: cargo, clippy, rustfmt

### 🐹 golang-backend-engineer
- **Expertise**: Go, Gin, GORM, concurrency
- **Tools**: go mod, golangci-lint, go test

### ☕ java-enterprise-engineer
- **Expertise**: Java, Spring Boot, JPA, microservices
- **Tools**: Maven/Gradle, SonarQube, JUnit

### 🟨 javascript-fullstack-engineer
- **Expertise**: Node.js, Express, TypeScript
- **Tools**: npm/yarn/pnpm, ESLint, Jest

### 💎 ruby-rails-engineer
- **Expertise**: Ruby, Rails, Sidekiq, RSpec
- **Tools**: bundler, rubocop, RSpec

## Usage Pattern

Language agents:
1. Understand language-specific patterns and idioms
2. Use appropriate package managers and tools
3. Follow language community standards
4. Integrate with language-specific testing frameworks