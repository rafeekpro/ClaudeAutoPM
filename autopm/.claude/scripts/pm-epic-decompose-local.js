/**
 * Epic Decomposition - Local Mode
 *
 * AI-powered decomposition of epics into right-sized tasks (4-8h each).
 * Generates task files with frontmatter, dependencies, and acceptance criteria.
 *
 * Usage:
 *   const { decomposeLocalEpic } = require('./pm-epic-decompose-local');
 *
 *   const result = await decomposeLocalEpic('epic-001', {
 *     aiProvider: new OpenAIProvider(),
 *     maxTasks: 10
 *   });
 */

const fs = require('fs').promises;
const path = require('path');
const { showLocalEpic } = require('./pm-epic-show-local');
const { updateLocalEpic } = require('./pm-epic-update-local');
const { stringifyFrontmatter } = require('../lib/frontmatter');
const { TaskGenerator } = require('../lib/ai-task-generator');
const { analyzeDependencies } = require('../lib/dependency-analyzer');
const { generateTaskId, generateTaskNumber, generateTaskFilename } = require('../lib/task-utils');

/**
 * Decompose epic into tasks using AI
 *
 * @param {string} epicId - Epic ID to decompose
 * @param {Object} options - Decomposition options
 * @param {Object} [options.aiProvider] - AI provider instance (for testing)
 * @param {number} [options.maxTasks=15] - Maximum tasks to generate
 * @param {boolean} [options.validateDependencies=false] - Validate dependency graph
 * @returns {Promise<Object>} Decomposition result
 */
async function decomposeLocalEpic(epicId, options = {}) {
  const {
    aiProvider = null,
    maxTasks = 15,
    validateDependencies = false
  } = options;

  // 1. Load epic
  const epic = await showLocalEpic(epicId);
  const epicDir = path.dirname(epic.path);

  // 2. Generate tasks using AI
  const generator = new TaskGenerator(aiProvider);
  const tasks = await generator.generate(epic.body, { maxTasks });

  // Handle empty response
  if (tasks.length === 0) {
    return {
      epicId,
      tasksCreated: 0,
      warning: 'No tasks generated by AI provider'
    };
  }

  // 3. Validate dependencies if requested
  if (validateDependencies) {
    const analysis = analyzeDependencies(tasks);
    if (analysis.hasCircularDependencies) {
      throw new Error(
        `Circular dependency detected: ${analysis.cycles.map(c => c.join(' -> ')).join(', ')}`
      );
    }
  }

  // 4. Create task files
  const taskIds = [];
  for (let i = 0; i < tasks.length; i++) {
    const task = tasks[i];
    const taskId = generateTaskId(epicId, i + 1);
    const taskFilename = generateTaskFilename(i + 1);
    const taskPath = path.join(epicDir, taskFilename);

    // Build task frontmatter
    const taskFrontmatter = {
      id: taskId,
      epic_id: epicId,
      title: task.title,
      status: 'pending',
      priority: task.priority || 'medium',
      estimated_hours: task.estimated_hours || 4,
      dependencies: task.dependencies || [],
      created: new Date().toISOString().split('T')[0]
    };

    // Build task body
    const taskBody = buildTaskBody(task);

    // Write task file
    const taskContent = stringifyFrontmatter(taskFrontmatter, taskBody);
    await fs.writeFile(taskPath, taskContent, 'utf8');

    taskIds.push(taskId);
  }

  // 5. Update epic with task count
  await updateLocalEpic(epicId, {
    tasks_total: tasks.length,
    tasks_completed: 0,
    task_ids: taskIds
  });

  return {
    epicId,
    tasksCreated: tasks.length,
    taskIds
  };
}

/**
 * Build task body content from AI-generated task
 *
 * @param {Object} task - Task object from AI
 * @returns {string} Markdown body content
 */
function buildTaskBody(task) {
  let body = `# ${task.title}\n\n`;

  // Description
  if (task.description) {
    body += `## Description\n\n${task.description}\n\n`;
  }

  // Acceptance Criteria
  body += `## Acceptance Criteria\n\n`;
  if (task.acceptance_criteria && task.acceptance_criteria.length > 0) {
    task.acceptance_criteria.forEach(criterion => {
      body += `- [ ] ${criterion}\n`;
    });
  } else {
    body += `- [ ] Implementation complete\n`;
    body += `- [ ] Tests passing\n`;
    body += `- [ ] Code reviewed\n`;
  }

  body += `\n`;

  // Technical Notes (if provided)
  if (task.technical_notes) {
    body += `## Technical Notes\n\n${task.technical_notes}\n\n`;
  }

  // Dependencies
  if (task.dependencies && task.dependencies.length > 0) {
    body += `## Dependencies\n\n`;
    task.dependencies.forEach(dep => {
      body += `- ${dep}\n`;
    });
    body += `\n`;
  }

  return body.trim();
}

module.exports = { decomposeLocalEpic };
